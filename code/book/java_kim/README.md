# 알기 쉽게 해설한 JAVA

김충석

### Contents
1.	[컴퓨터와 프로그램 그리고 자바](#컴퓨터와-프로그램-그리고-자바)
2.	[자바의 환경](#자바의-환경)
3.	[자바의 기본 구조1: 변수, 자료형, 연산자](#자바의-기본-구조1-변수-자료형-연산자)
4.	[자바의 기본 구조2: 선택, 반복, 배열](#자바의-기본-구조2-선택-반복-배열)
5.	[객체지향 개념](#객체지향-개념)
6.	[클래스: 속성](#클래스-속성)
7.	클래스: 기능
8.	상속
9.	인터페이스와 예외처리
10.	~~다중 스레드~~
11.	~~패키지와 주요 클래스~~
12.	~~입출력~~
13.	~~네트워킹~~
14.	~~그래피컬 사용자 인터페이스~~
15.	~~이벤트 처리~~
16.	~~스윙~~


## 컴퓨터와 프로그램 그리고 자바

개발자가 작성한 프로그램이 컴퓨터에서 실행되기 위해서 무조건 컴퓨터가 인식할 수 있는 0과 1의 형태로 번역되어야 한다. 프로그램을 번역하여 실행하는 방법은 다음과 같다.

1. 컴파일(Compile) 기법
   * 0과 1로 번역해주는 컴파일러가 반드시 필요함. (ex. C언어로 작성된 프로그램을 실행시키기 위해서는 C컴파일러가 반드시 필요)
   * 컴파일러에 의해 번역된 프로그램은 언제든지 실행될 수 있는 프로그램임. 
   * (장점) 컴파일되어 실행파일만 되기만 하면 다음부터는 번역 절차 없이 실행 파일만 실행시키므로 실행시간의 효율성이 뛰어남.
   * (단점) 특정 시스템(ex. 윈도우)에서 번역된 실행파일은 다른 시스템(ex. 리눅스)에서는 실행되지 않음. 다른 시스템에서 실행하기 위해서는 그 시스템에서 다시 번역작업을 수행하여 실행파일을 생성해야 함.
   * 대표적인 컴파일 기법의 언어로 C언어가 있음.

2. 인터프리트(Interprete) 기법
   * 인터프리터에 프로그램을 실행시키는 방법. 컴파일과 다르게 0과 1로 구성된 실행파일을 생성하지 않음.
   * 프로그램을 직접 한 줄씩 번역한 다음 바로 실행시켜 결과를 나타냄.
   * 주로 스크립트 언어(ex. HTML, Javascript, ASP, PHP, Perl, Python)들이 대부분 인터프리트 기법을 사용.
   * (장점) 컴파일러 방법에 비해 배우기 쉽고, 이식성이 뛰어남.
   * (단점) 프로그램 자체가 공개되고 실행시간이 느림.

3. 하이브리드(Hybrid) 기법
   * 컴파일 기법과 인터프리트 기법을 모두 사용함.
   * 특징은 중간코드(ex. 바이트 코드, .class 파일)를 사용함. 중간코드는 다양한 형태의 서로 다른 시스템에서 인터프리터에 의해 직접 실행됨.
   * 컴퓨터, 운영체제에 상관없이 실행되는 하드웨어에 독립적인 코드
   * (장점) 인터프리터 단점인 소스코드 공개하지 않아도 됨. 컴파일러 단점인 특정 컴퓨터에 종속성을 벗어남.
   * (장점) 한 번 작성된 프로그램은 어떤 컴퓨터 시스템에서든지 즉시 실행될 수 있어 이식성이 매우 높음. 이러한 이식성은 네트워크(인터넷) 환경에서 특히 강한 면모를 보임.
   * 자바, C# 등이 있음.
 
자바는 완전한 객체지향 언어(Object Oriented Language)이며, 객체지향의 특성인 클래스, 상속, 캡슐화, 다형성 등의 개념이 잘 적용된 언어이다. 객체지향 프로그래밍은 우리가 살아가는 실세계와 동일한 사고방식의 프로그램이다. 자바의 객체지향 모델은 단순하며 쉽게 확장될 수 있는 개념을 가진다. 객체지향에서는 모든 것을 객체로 표현하지만, 자바 언어는 정수 또는 실수와 같이 많이 사용되는 요소들을 객체는 물론 성능을 높이기 위해 기본 자료형(primitive type)으로도 제공하고 있다. 

자바는 운영체제 독립적이다. 자바 프로그램은 JVM(Java Virtual Machine)이 구축된 컴퓨터에서는 어디에서든지 실행시킬 수 있다. JVM은 소프트웨어로 구성된 에뮬레이터(Emulator: 대리실행기)로서 운영체제와 자바 프로그램 사이에서 자바 프로그램이 실행될 수 있는 환경을 제공한다. 

## 자바의 환경

자바 언어를 사용하여 작성할 수 있는 프로그램의 형태는 매우 다양하며, 광범위한 적용 범위를 가지고 있다. 또한, 자바 개발 환경도 작성하는 프로그램의 특성(적용 분야와 규모)에 따라 다르게 제공되고 있다. 일반적으로 자바 프로그램은 다음과 같은 형태로 구분될 수 있다.

* 자바 응용 프로그램: C 프로그램과 같이 일반적인 응용 프로그램이다. 사용자는 CUI나 GUI와 같은 인터페이스를 이용하여 프로그램을 사용하게 된다. 
* 자바 애플릿: 웹 검색기상에서 작동하는 프로그램이다. 웹의 표준 언어인 HTML로 애플릿을 지정하면, 웹서버로부터 애플릿이 네트워크를 통하여 검색기로 다운로드 되어 실행되는 형태이다. 웹 검색기에는 애플릿을 해석하여 실행할 수 있는 인터프리터가 내장되어 있다.
* 자바 서블릿(Servlet): 웹 환경에서 실행되는 자바 프로그램이다. 서버에서 실행되는 프로그램으로 웹 검색기에서 실행되는 응용에 적합하다. 서버의 실행 결과를 웹 클라이언트가 볼 수 있는 HTML로 만들어 나타내는 프로그램이다. 주로 데이터베이스와 연동하는 프로그램이 서블릿으로 작성된다.
* JSP(Java Server Page): 서블릿과 비슷한 형태이나, HTML 속에 자바 코드를 삽입하여 사용하는 형태이다.
* 자바 빈스(Beans): 자바로 작성한 프로그램들을 부품처럼 사용하여 프로그래밍하는 방법이다. 주로 대규모의 프로그램 개발 시 사용하는 방법이다.


(자바 노트) <br>

* Stack영역(지역변수), Heap영역(동적으로 할당되는 부분 - C언어: malloc( )-free( ), C++언어: new-delete), Data영역(전역변수, 정적변수)
* Java에서는 실행시키기 위해서는 반드시 객체를 생성해야 하는데, 객체를 생성하지 않고 바로 메모리상에 할당하기 위해서 static 키워드를 사용한다. (static만 붙어있으면 객체를 생성하지 않아도 된다) 
* 하나의 문자(character)를 표현할 때, C 언어는 7비트 아스키코드를 사용하지만, JAVA는 16비트 유니코드를 사용한다. 하나의 파일 안에 public이 2개 들어갈 수는 없다. 일반적으로 main 함수가 있는 쪽에 public이 들어간다. 하나의 파일에 여러 개의 class가 있는 경우. 여러 개의 class 중에서 하나의 class에만 public을 붙일 수 있다.Public이 붙은 class가 있으면 그 class 이름으로 파일명을 작성해서 저장해야 한다. (그러나 실행 시에는 main 함수가 있는 class 이름으로 실행해야 한다)


## 자바의 기본 구조1: 변수, 자료형, 연산자

변수는 값을 가진다. 변수가 가질 수 있는 값의 형태를 자료형(Data Type)이라고 한다. 자바의 자료형은 크게 2가지로 구분될 수 있다. 
  * 기본 자료형(primitive type) – int a = 10; 기본 자료형으로서 변수로 지정된 위치에 값이 저장됨
  * 참조 자료형(reference type) – Integer b = new Integer(10); 차조 자료형으로서 변수로 지정된 위치에는 실제 값이 있는 곳의 주소가 저장됨.

자바는 객체지향 언어이기 때문에 프로그램 내의 모든 요소들을 객체로 표현할 수 있지만, 실행시간의 효율성을 위해 가장 많이 사용되는 8개의 자료형을 기본 자료형으로 제공한다. (기본 자료형 – 정수형(byte, short, int, long), 실수형(float, double), 논리형(Boolean), 문자형(char))

자바의 4가지 정수형은 최상위 비트를 부호비트로 사용하고 있다. 음수표기법은 다음과 같이 2가지 방식이 있다. (둘 다 최상위 비트를 부호비트로 사용하는 것은 동일하다)
  -	(1) 부호비트에 의한 음수표기법
  -	(2) 2의 보수를 사용한 음수표기법 - 모든 비트를 반전하고 +1을 한다

2의 보수법을 사용한 음수 표기법 예제) <br>
만약, byte 자료형에서 예를 들어, 1000 0000을 보면, 최상위 비트가 1이므로 음수로 취급한다. 여기서 십진수로 바꾸기 위해서 2의 보수법을 사용한다. 1000 0000의 반전인 0111 1111에서 +1을 해서 1000 0000이 나온다. 십진수로 해석하면 128이고, 음수이기 때문에 -128이라는 최종 결과가 나온다. (-128인데 인코딩이 1000 0000으로 된다는 것을 기억하자; 이렇게 최상위 비트가 부호비트 이므로 8비트 정수 범위가 -128~127이 되는 것이다)

자바에서는 하나의 문자를 나타낼 수 있는 char형을 기본 자료형으로 제공한다. 기존의 언어들이 대부분 사용하고 있는 아스키코드(8비트)가 아닌 유니코드(16비트)를 사용한다. 유니코드를 사용함으로써 자바는 세계 다양한 나라들의 모든 언어를 나타낼 수 있다. (최대 65,536개의 문자)

자바에서는 특수한 문자를 나타내기 위해 역슬래시(backslash)를 사용한다.

```
public class PrimitiveType {
	public static void main(String args[ ])
	{
		byte a = 127;
		short b = 32767;
		int c = 2137483647;
		long d = 9223372036854775807L;
		float a = 0.12345678901234567890f;
		double b = 0.12345678901234567890;
		char grade = ‘A’;
		char grade1 = ‘\u0041’;	// ‘A’와 같은 의미의 유니코드
		char year = ‘2018’;
		char name = ‘김영수’;
		char char1 = ‘\t’;
		char char2 = ‘\n’;
		System.out.println(…);
	}
}
```

비트(bit) 연산자 <br>
비트 연산자는 비트 단위로 연산할 수 있는 연산자이다. 비트 단위의 연산은 정수형의 데이터에만 적용이 가능하다. 

문자열(String) <br>
자바에서의 문자열은 기본 자료형으로 제공되고 있지 않고, String 클래스로 구현되어 있다. 빈번하게 사용되기 때문에 기본 자료형과 같이 변수로 사용될 수 있다.

```
public class StringTest {
	public static void main(String args[ ]) {
		String str1 = “대한민국”;
		String str2 = new String(“대한민국!”); 	// 원래 이렇게 new로 선언. 
  }
}
```
여기서 str1과 str2는 참조 자료형으로 주소가 들어간다 (C 언어와 비교하면 *이 있는 것과 같다)

## 자바의 기본 구조2: 선택, 반복, 배열

자바에서의 배열을 사용하기 위해서는 배열을 선언하고, 생성해주어야 한다.
```
type name[ ] = new type[size]
type name[ ][ ] = new type[size][size];
type name[ ][ ][ ] = new type[size][size][size];

```
배열의 첫 번째 axis는 필수적으로 size를 정해줘야 한다. 나머지 axis들은 size를 정해줘도 되고 안정해줘도 된다.
```
int[ ][ ] score = new int[2][ ];
score[0] = new int[2];
score[1] = new int[3];
score[2] = new int[4];

```
위와 같이 2차원 배열이지만 각 행의 요소의 개수가 다르게 생성할 수 있다. (C 언어에서는 2차원 배열의 열의 개수가 일정하게 생성해야 하지만, Java에서는 유동적으로 원하는 개수만큼 생성할 수 있다)

배열의 선언과 생성과정을 거치면 배열을 사용하기 위해 초기화를 해야한다.
```
int id[ ] = new int[3];
int[0] = 20119501;
int[1] = 20119502;
int[2] = 20119503;

int id[ ] = { 20119501, 20119502, 20119503 };	// 이렇게 한 문장으로 하는 게 좋다

```
위와 같이 한 문장으로 생성과 초기화 과정을 다 거치는 형태가 C언어랑 동일하다.

그런데… C언어는 int id[3]; 이 되는데, 자바는 int id[3]; 은 에러가 뜬다 (int id[ ]; 는 또 괜찮다). 왜 그럴까? C언어는 변수를 선언하기만 해도 메모리에 할당이 되지만, 자바는 객체지향 언어로서 (기본 자료형은 제외하고) new로 생성해야 메모리에 할당이 된다. (자바에서 배열을 사용하기 위해서 반드시 선언과정과 생성과정이 필요하다)

## 객체지향 

자바는 객체지향(Object-Oriented) 언어이다. 객체지향 이론은 컴퓨터를 통하여 실세계와 같은 환경을 흉내(simulation)내기 위해 발전한 이론이다. 실세계는 사물(객체)로 구성되어 있으며, 이러한 사물들이 상호작용에 의해 실세계는 작동한다. 

실세계의 사물을 분석해보면 사물은 “속성+기능”으로 구성되어 있음을 알 수 있다. 객체지향 이론은 실세계의 모든 사물들을 속성과 기능으로 정의하고, 사물들 간의 상호작용을 정의하여 실제 세계를 흉내내는 이론이다.

객체지향 이론은 1960년대 클래스(class), 상속(inheritance), 상속화(encapsulation), 다형성(polymorphism) 등의 개념을 중심으로 발전하였다.

객체지향 언어의 개념과 대비되는 언어로서 절차지향(procedural-oriented) 언어가 있다.

절차지향 언어로 작성된 프로그램에서 프로그램의 기본 단위는 절차(procedure) 또는 함수(function)로 정의된다. 이러한 절차나 함수는 기능을 정의하는데 사용되며, 공통으로 사용되는 속성(데이터)들은 절차나 함수에 의해 공유되는 형태이다. 이러한 형태에서는 공유되는 속성(데이터)의 형태가 바뀌면 모든 함수의 내용이 변경되어야 하는 결정적 단점을 가지고 있다.

반면, 객체지향 언어에서는 프로그램의 기본단위가 객체이며, 객체는 “속성+기능”으로 구성된다. 객체지향 언어에서는 모든 요소들을 반드시 객체로 표현해야 하며, 프로그래밍은 이러한 객체의 생성과 생성된 객체의 상호관계를 설정하는 것으로 이루어진다.

객체지향의 장점 <br>
객체지향 프로그램의 개념은 우리들의 실생활과 같은 개념의 프로그램 방식을 제공한다.
  * 문제를 쉽고 자연스럽게 프로그램화(모델링) 할 수 있다 (클래스, 캡슐화, 다형성 등을 통해)
  * 쉬운 프로그램의 개발로 인한 생산성을 향상시킬 수 있다. (객체들은 독립성을 가짐. 객체들을 서로 연결하여 프로그램을 완성할 수 있음)
  * 프로그램 모듈을 재사용할 수 있다. (독립된 모듈은 다양한 프로그램에서 재사용될 수 있음)

클래스 <br>
객체지향에서는 동일한 속성과 기능을 가진 객체를 생성하기 위해 클래스라는 형판(template)을 제공하고 있다. 즉, 클래스는 하나의 클래스로부터 여러 개의 객체를 생성하기 위해 사용하는 형판 즉, 틀이라 보면 된다.

객체는 “속성+기능”으로 구성되기 때문에 객체를 생성하는 클래스 역시 “속성+기능”으로 구성된다. (속성: 변수, 기능: 함수)

객체 <br>
클래스로부터 객체를 생성하는 과정을 실체화(instantiation)라고 하고, 객체를 인스턴스(instance)라 부르기도 한다.

하나의 클래스로부터 객체가 생성될 때 각 객체는 같은 속성과 기능을 가지지만, 속성에 저장된 값은 모두 다르게 지정할 수 있다.

```
class Avg {
	String name;
	int avg;
	public String average(int kor, int eng) {
		avg = (kor + eng) / 2;
		return name + avg
	}
}

public class AvgTest {
	public static void main(String[ ] args) {
		Avg student1 = new Avg( );
		Avg student2 = new Avg( );
		student1.name = “김철수”;
		student2.name = “김영희”;
		String str1_avg = student1.average(70, 80);
		String str2_avg = student2.average(80, 90);
		System.out.println(str1_avg);
		System.out.println(str2_avg);
	}
}
```

**상속(Inheritance)** <br>
student 객체와는 비슷하지만 속성과 함수가 약간 다른 객체를 생성하려면 어떻게 해야 하나? 처음부터 다 설계해야 할까? 아니다. 객체지향이니까, 기존에 있는 student 객체를 활용할 수 있다. 어떻게? 상속을 이용한다. 즉, 기존 클래스로부터 모든 속성과 메소드를 상속받고, 더 필요한 속성과 메소드를 추가하여 새로운 클래스를 생성할 수 있다. 이러한 개념이 상속이다.
```
class Avg {
	String name;
	int avg;
	public String average(int kor, int eng) {
		avg = (kor + eng) / 2;
		return name + avg
	}
}
class AvgTotal extends Avg {
	public int total(int kor, int eng) {
		int score = kor + eng;
		return score;
	}
}
public class AvgTest2 {
	public static void main(String[ ] args) {
		AvgTotal student1 = new AvgTotal( );
		AvgTotal student2 = new AvgTotal( );
		student1.name = “김철수”;
		student2.name = “김영희”;
		String str1_avg = student1.average(70, 80);
		String str2_avg = student2.average(80, 90);
		int st1_total = student1.total(70, 80);
		int st2_total = student2.total(80, 90);
		System.out.println(str1_avg+” 총점=”+st1_total);
		System.out.println(str2_avg+” 총점=”+st2_total);
	}
}
```
클래스의 상속은 확장(entend)의 개념을 가진다. 즉, 상위 클래스의 모든 것을 상속받고 추가로 더 가지는 클래스를 구성하는 것이 상속이다. (상위 클래스로 갈수록 general해지고, 하위 클래스로 갈수록 specific해진다)

클래스들 사이의 상속은 소프트웨어 설계를 간단하게 할 수 있는 이점을 제공한다. 즉, 기존의 클래스로부터 모든 요소를 상속받고 새로운 클래스에는 추가되는 자료구조와 메소드만 지정하면 된다. 상속의 개념은 코드를 간결하게 하고, 코드의 재사용성(resusing)을 높이는 요인이 된다.

다수 개의 클래스로부터 상속받아 새로운 클래스를 생성하는 경우도 있다. 이를 다중상속(multiple inheritance)라 한다. 자바는 상속관계에서 하나의 상위 클래스만 허용하며, 다중상속은 허용하지 않는다.

**캡슐화(Encapsulation)** <br>
객체는 속성과 속성을 처리하는 메소드를 가지고 있다. 객체를 사용하는 쪽에서는 그 객체의 인터페이스만 알면 그 객체를 충분히 사용할 수 있다. 객체가 실제 데이터를 어떻게 처리하는지는 알 필요가 없고, 실제 처리방법은 숨겨져야 한다. 이러한 개념이 캡슐화이다.

클래스를 작성할 때 프로그램 작성자는 숨겨야 하는 정보(private)와 공개해야 하는 정보(public)를 구분하여 기술할 수 있다. 객체를 사용하는 사람은 객체 중에 공개하는 정보에만 접근할 수 있다. 이러한 기법을 제공함으로써 객체의 사용자로부터 정보를 은폐(information hiding)할 수 있다.

캡슐화를 통한 정보의 은폐
-	객체에 포함된 정보의 손상과 오용을 막을 수 있다
-	객체 내부의 조작 방법이 바뀌어도 사용방법은 바뀌지 않는다
-	데이터가 바뀌어도 다른 객체에 영향을 주지 않아 독립성이 유지된다
-	처리된 결과만 사용하므로 객체의 이식성이 좋다
-	객체를 부품화 할 수 있어 새로운 시스템의 구성에 부품처럼 사용할 수 있다

**메시지(Message)** <br>
메시지는 객체에 일을 시키는 행위라 할 수 있다. 프로그램에서 생성된 객체들은 이러한 메시지를 주고받음으로써 일을 수행한다. 프로그램 작성자는 사용하고자 하는 객체를 정의한 다음 이러한 객체들이 어떤 일을 수행해야 하는지를 메시지로 기술해야 한다. 일반적으로 메시지에는 메시지를 받을 객체의 이름, 메소드 이름, 메소드의 수행에 필요한 인자(argument)들을 포함한다.

메시지의 예시)
```
public class AvgTest {
	public static void main (String[ ] args) {
		AvgTotal student1 = new AvgTotal( );
		String str1_avg = student1.average(70, 80);	// 객체의 메소드 호출 메시지
		int st1_total = student1.total(70, 80);	// 객체의 메소드 호출 메시지
	}
}
```

**다형성(Polymorphism)** <br>
다양한(poly) 변신(morphism)을 의미하는 그리스어에 기원을 둔다. 즉, 서로 다른 객체가 동일한 매시지에 대하여 서로 다른 방법으로 응답할 수 있는 기능이다. “서로 다른 객체”, “동일한 메시지”, “서로 다른 방법”
```
class Avg3 {
	public String name;
	private int avg;
	public String average(int kor, int eng) {	// 매개변수가 2개일 때 수행
		avg = (kor + eng) / 2;
		return name + “ 두 과목 평균 : “ + avg;
	}
	public String average(int kor, int eng, int mat) {	// 매개변수가 3개일 때 수행.
		avg = (kor+eng+mat) / 3;
		return name+ “ 세 과목 평균 : “+ avg;
	}
}
public class AvgTest3 {
	public static void main(String[ ] args) {
		Avg3 student1 = new Avg3( );
		Avg3 student2 = new Avg3( );
		student1.name = “김철수”;
		student2.name = “김영희”;
		String st1_avg = student1.average(70, 80);		// 다른 객체 동일 메시지
		String st2_avg = student2.average(70, 80, 90);	// 다른 객체 동일 메시지
		System.out.println(st1_avg);
		System.out.println(st2_avg);
	}
}
```

## 클래스: 속성











